# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

before_all do
  setup_circle_ci
  update_fastlane
end

desc "Increment build number and update changelog"
lane :bump_and_update_changelog do |options|
  new_version_number = options[:version]
  previous_version_number = current_version_number
  sh "fastlane ios bump version:#{new_version_number}"
  sh "fastlane android bump version:#{new_version_number}"
  attach_changelog_to_main(options)
  increment_version_in(previous_version_number, new_version_number, "../.version")
end

desc "Make GitHub release for current version"
lane :github_release_current do |options|
  version_number = current_version_number
  github_release(version: version_number)
end

desc "Make GitHub release for specific version"
lane :github_release do |options|
  release_version = options[:version]
  fail ArgumentError, "missing version" unless release_version

  begin
    changelog = File.read("../CHANGELOG.latest.md")
  rescue
    fail "please add a CHANGELOG.latest.md file before calling this lane"
  end
  commit_hash = last_git_commit[:commit_hash]
  puts commit_hash

  is_prerelease = release_version.include?("-")

  set_github_release(
    repository_name: "revenuecat/purchases-hybrid-common",
    api_token: ENV["GITHUB_TOKEN"],
    name: release_version,
    tag_name: "#{release_version}",
    description: changelog,
    commitish: commit_hash,
    upload_assets: ["PurchasesHybridCommon.framework.zip"],
    is_draft: false,
    is_prerelease: is_prerelease
  )
end

desc "Update dependencies to latest GitHub releases"
lane :update_native_dependencies_to_latest do |options|
  current_ios_version = parse_previous_ios_native_version
  latest_ios_release = get_latest_github_release_within_same_major(repo_name: "purchases-ios", current_version: current_ios_version)
  
  current_android_version = parse_previous_android_native_version
  latest_android_release = get_latest_github_release_within_same_major(repo_name: "purchases-android", current_version: current_android_version)

  update_ios_native_version(new_version: latest_ios_release, current_version: current_ios_version)
  update_android_native_version(new_version: latest_android_release, current_version: current_android_version)

  run_pod_install
end

desc "Update purchases-ios dependency version"
lane :update_ios_native_version do |options|
  new_version_number = options[:new_version]
  previous_version_number = options[:current_version]
  files_to_update = [
    'PurchasesHybridCommon.podspec',
    'ios/PurchasesHybridCommon/Podfile',
    'DEVELOPMENT.md',
  ]

  update_native_version(
    platform_name: "iOS", 
    new_version_number: new_version_number, 
    previous_version_number: previous_version_number,
    files_to_update: files_to_update
  )
end

desc "Update purchases-android dependency version"
lane :update_android_native_version do |options|
  new_version_number = options[:new_version]
  previous_version_number = options[:current_version]
  files_to_update = [
    'android/build.gradle',
  ]

  update_native_version(
    platform_name: "Android", 
    new_version_number: new_version_number, 
    previous_version_number: previous_version_number,
    files_to_update: files_to_update
  )
end

desc "Update purchases-android dependency version"
lane :update_native_version do |options|
  platform_name = options[:platform_name]

  dry_run = options[:dry_run]
  if options[:new_version_number]
    new_version_number = options[:new_version_number]
  else
    UI.user_error!("Missing `version` argument")
  end

  previous_version_number = options[:previous_version_number]
  
  if previous_version_number == new_version_number
    UI.message("ℹ️  #{platform_name} is already in its latest version: #{previous_version_number}")
    next previous_version_number
  end

  UI.message("ℹ️  Updating #{platform_name} from #{previous_version_number} to #{new_version_number}")
  files_to_update = options[:files_to_update]

  if dry_run
    UI.message("ℹ️  Nothing more to do, dry_run: true")
  else
    Dir.chdir(get_root_folder) do
      for file_to_update in files_to_update
        increment_build_number(previous_version_number, new_version_number, file_to_update)
      end
    end
  end
  new_version_number
end

desc "Run pod install"
lane :run_pod_install do |options|
  Dir.chdir(File.expand_path('ios/PurchasesHybridCommon', get_root_folder)) do
    sh("pod install --repo-update")
  end
end

platform :ios do

  desc "Increment build number"
  lane :bump do |options|
    new_version_number = options[:version]
    fail ArgumentError, "missing version" unless new_version_number
    previous_version_number = get_version_number(xcodeproj: "ios/PurchasesHybridCommon/PurchasesHybridCommon.xcodeproj",
                                                 target:"PurchasesHybridCommon")
    increment_version_number(version_number: new_version_number, xcodeproj: "ios/PurchasesHybridCommon/PurchasesHybridCommon.xcodeproj")
    version_bump_podspec(path: "PurchasesHybridCommon.podspec", version_number: new_version_number)
  end
  
  desc "Release to CocoaPods, create Carthage archive, and create GitHub release"
  lane :release do |options|
    version_number = current_version_number
    push_pods
    archive
  end

  desc "replace API KEY for integration tests"
  lane :replace_api_key_integration_tests do
    folder = '../ios/PurchasesHybridCommon/PurchasesHybridCommonIntegrationTests/'

    replace_in("REVENUECAT_API_KEY", ENV["REVENUECAT_API_KEY"], "#{folder}/Constants.swift")
    replace_in("REVENUECAT_PROXY_URL", ENV["REVENUECAT_PROXY_URL"].to_s, "#{folder}/Constants.swift", allow_empty: true)
  end
end

platform :android do
  desc "Increment build number"
  lane :bump do |options|
    new_version = options[:version]
    fail ArgumentError, "missing version" unless new_version
    gradle_file_path = "android/build.gradle"
    previous_version = android_get_version_name(gradle_file: gradle_file_path)
    android_set_version_name(version_name: new_version, gradle_file: gradle_file_path)
    increment_version_in(previous_version, new_version, '../android/gradle.properties')
  end

  desc "Upload and close a release"
  lane :deploy do |options|
    gradle_file_path = "android/build.gradle"
    version = android_get_version_name(gradle_file: gradle_file_path)
    gradleProperties = {
      "signing.keyId" => ENV['GPG_SIGNING_KEY_ID'],
      "signing.password" => ENV['GPG_SIGNING_KEY_PW'],
      "signing.secretKeyRingFile" => "./secring.gpg",
      "mavenCentralUsername" => ENV['SONATYPE_NEXUS_TOKEN_USERNAME'],
      "mavenCentralPassword" => ENV['SONATYPE_NEXUS_TOKEN_PASSWORD'],
      "RELEASE_SIGNING_ENABLED" => true
    }
    UI.verbose("Deploying #{version}")
    
    gradle(
      tasks: [
        "androidSourcesJar", "androidJavadocJar", "publish --no-daemon --no-parallel"
      ],
      properties: gradleProperties,
      project_dir: 'android'
    )

    UI.verbose("Creating special version for Unity IAP with BillingClient 3 and Amazon 2 for version: #{version}")
    gradleProperties["PUBLISH_VARIANT"] = "unityIAPRelease"
    
    UI.verbose("Adding -unityiap to artifact ids")

    gradle(
      tasks: [
        "androidSourcesJar", "androidJavadocJar", "publish --no-daemon --no-parallel"
      ],
      properties: gradleProperties,
      project_dir: 'android'
    )
    
    unless is_snapshot_version?(version)
      gradle(
        tasks: [
          "closeAndReleaseRepository"
        ],
        properties: gradleProperties,
        project_dir: 'android'
      )
    end
  end
end

def attach_changelog_to_main(options)
  version_number = options[:version]
  current_changelog = File.open("../CHANGELOG.latest.md", 'r')
  master_changelog = File.open("../CHANGELOG.md", 'r')

  current_changelog_data = current_changelog.read
  master_changelog_data = master_changelog.read

  current_changelog.close
  master_changelog.close

  File.open("../CHANGELOG.md", 'w') { |master_changelog_write_mode|
    version_header = "## #{version_number}"
    whole_file_data = "#{version_header}\n\n#{current_changelog_data}\n#{master_changelog_data}"
    puts "going to save. Contents - #{whole_file_data}"
    master_changelog_write_mode.write(whole_file_data)
  }
end

def increment_version_in(previous_version, new_version, path)
  sed_regex = 's|' + previous_version + '|' + new_version + '|'
  backup_extension = '.bck'
  sh("sed", '-i', backup_extension, sed_regex, path)
end

def current_version_number
  File.read("../.version")
end

def push_pods
  pod_push(path: "PurchasesHybridCommon.podspec", synchronous: true)
end

def archive
  match(type: "appstore")
  framework_filename = "PurchasesHybridCommon.framework"
  build_app(
    workspace: "ios/PurchasesHybridCommon/PurchasesHybridCommon.xcworkspace",
    configuration: "Release",
    scheme: "PurchasesHybridCommon",
    silent: true,
    clean: true,
    derived_data_path: "derived_data/",
    output_name: framework_filename,
    destination: 'generic/platform=iOS',
    export_method: "app-store"
  )

  # fastlane gym doesn't fully support .frameworks, so we need to look for the output
  # in derived data manually. 
  Dir.chdir("..") do
    output_framework_path = Dir["derived_data/**/#{framework_filename}"].first
    UI.error("framework not found!") if output_framework_path.nil?

    # compress using ditto because zip can cause issues with symlinks
    sh("ditto", "-c", "-k", "--sequesterRsrc", "--keepParent", 
      output_framework_path, 
      "#{framework_filename}.zip")
  end

end

def is_snapshot_version?(version_name)
  version_name.end_with?("-SNAPSHOT")
end

def replace_in(previous_text, new_text, path, allow_empty=false)
  if new_text.to_s.strip.empty? and not allow_empty
    UI.user_error!("Missing `new_text` in call to `replace_in`, looking for replacement for #{previous_text} 😵.")
  end
  sed_regex = 's|' + previous_text.sub(".", "\\.") + '|' + new_text + '|'
  backup_extension = '.bck'
  sh("sed", '-i', backup_extension, sed_regex, path)
end

def parse_previous_android_native_version
  parse_version_in_file(/(?<=ext\.purchases_version = ["'])(.*)(?=["'])/, "android/build.gradle")
end

def parse_previous_ios_native_version
  parse_version_in_file(/(?<=s\.dependency ["']RevenueCat["'], ["'])(.*)(?=["'])/, "PurchasesHybridCommon.podspec")
end

def parse_version_in_file(pattern, path)
  Dir.chdir(get_root_folder) do
    File.open path do |file|
      line = file.find { |line| line =~ pattern }
      return line.match(pattern)[1] unless line.nil?
    end
  end
  UI.user_error!("Couldn't extract version from #{path}")
end

def get_root_folder
  File.expand_path('../../', __FILE__)
end

def increment_build_number(previous_version_number, new_version_number, file_path)
  replace_in(previous_version_number, new_version_number, file_path)
end